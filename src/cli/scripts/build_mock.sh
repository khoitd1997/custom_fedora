#!/bin/bash
# script to be used to build OS inside mock env
# expected to be executed in the base dir inside mock

set -e
# set -x

# import function and variable
source /build_share/scripts/set_env_var.sh
source ${env_script_dir}/exit_code.sh
source ${env_script_dir}/misc_utils.sh
source ${env_script_dir}/build_utils.sh

# function error_callback {
#     exit ${error_build_failed}
# }
# trap error_callback ERR

cat > /etc/dnf/dnf.conf << EOF
[main]
keepcache=1
debuglevel=2
reposdir=/etc/yum.repos.d/
logfile=/var/log/yum.log
retries=20
obsoletes=1
gpgcheck=1
assumeyes=1
syslog_ident=mock
syslog_device=
install_weak_deps=0
best=1
max_parallel_downloads=10
clean_requirements_on_remove=True
metadata_expire=-1
module_platform_id=platform:f${env_releasever}
EOF

# cache_dir=/package_cache
# if [ "${env_clear_cache}" = true ]; then
#     rm -rf ${cache_dir}
# fi
# mkdir -p ${cache_dir}
#-----------------------------------------------------

build_project_file_structure

if [ -f ${env_prev_var_path} ]; then
    source ${env_prev_var_path}
fi
rm -f ${env_prev_var_path} # TODO(kd): Remove after test
${env_share_dir}/hatter_config_builder_parser
# save configs if parser succeeded
if [ $? -ne 0 ]; then
    print_error "toml parser failed"
else
    print_info "toml parser succeeded"
    cp ${env_var_path} ${env_prev_var_path}
    sed '/env_/s/env_/prev_env_/' -i ${env_prev_var_path}
fi

if [ "${env_parser_mode}" = false ]; then
    # get variables generated by config_builder
    source ${env_config_builder_env_var_path}

    # if first build, build base image
    if [ "${env_is_first_build}" = true ]; then
        print_info "building base image"
        rm -f ${env_build_dir}/${env_base_image_name}

        base_kickstart_name="${env_stock_kickstart_dir}/${env_base_kickstart_name}.ks"
        git -C ${env_stock_kickstart_dir} checkout ${env_base_kickstart_tag} -q
        ksflatten --config ${base_kickstart_name} \
                  -o ${env_base_kickstart_path} \
                  --version F${env_releasever}

        rm -rf ${env_base_image_dir} # TODO(kd): Remove after test
        livemedia-creator --ks ${env_base_kickstart_path} \
                          --resultdir ${env_base_image_dir} \
                          --project ${env_os_name} \
                          --volid ${env_os_name} \
                          --iso-name ${env_base_image_name} \
                          --releasever ${env_releasever} \
                          --title ${env_os_name} \
                          --no-virt --macboot --make-iso --iso-only
        print_info "done building base image"
    fi

    # if [ "${env_enable_custom_cache}" = true ]; then
    # package_list=""
    # group_list=""
    # raw_package_list=$(awk '/%packages/{flag=1;next}/%end/{flag=0}flag' flat-${generated_ks}.ks)
    # createrepo ${cache_dir} -q
    #     while read -r ks_line; do
    #         # parse groups
    #         if [[ "$ks_line" =~ ^@.* ]]; then
    #             group_name=$(cut -d "@" -f 2 <<< "$ks_line")
    #             group_list="${group_list} ${group_name}"
        
    #         else
    #             # check if it's a delete package
    #             if [[ ! "$ks_line" =~ ^-.* ]]; then
    #                 if [ ! -z "$ks_line" ]; then
    #                     package_list="${package_list} ${ks_line}"
    #                 fi
    #             fi
    #         fi
    #     done <<< "$raw_package_list"

    #     # printf ${package_list}
    #     dnf groupinstall --downloadonly --downloaddir=${cache_dir} ${group_list} 
    #     dnf --downloadonly --forcearch=x86_64 --allowerasing --best --downloaddir=${cache_dir} install ${package_list} 
    #     createrepo ${cache_dir} -q
    # fi

    # livemedia-creator --ks flat-${generated_ks}.ks --no-virt \
    # --resultdir ${iso_dir} --project ${env_os_name} --make-iso --volid ${env_os_name} \
    # --iso-only --iso-name ${generated_ks}.iso --releasever ${env_releasever} \
    # --title ${env_os_name} --macboot

    print_info "building final image"
    export LOGNAME=${USER}
    editliveos -n :${env_os_name} \
               -o ${env_out_dir} \
               -k ${env_main_kickstart_path} \
               -d ${env_base_image_path}
    print_info "done building final image"
fi