#include "utils.hpp"

#include <assert.h>
#include <ctype.h>
#include <libgen.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#include <algorithm>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <regex>
#include <sstream>
#include <string>
#include <vector>

namespace hatter {
namespace {
std::string buildRipgrepSearchFileCommand(const std::string&           searchTarget,
                                          const std::filesystem::path& targetFilePath,
                                          const bool                   useRegex) {
    const std::string regexFlag     = (useRegex) ? " " : " -F ";
    const std::string baseRgCommand = "rg " + regexFlag + " -c ";

    return baseRgCommand + searchTarget + " " + targetFilePath.string();
}

std::string buildRipgrepSearchOutputCommand(const std::string& searchTarget,
                                            const std::string& cmd,
                                            const bool         useRegex) {
    const std::string regexFlag     = (useRegex) ? " " : " -F ";
    const std::string baseRgCommand = "rg " + regexFlag + " -c ";

    return cmd + " | " + baseRgCommand + searchTarget;
}
}  // namespace

int ripgrepSearchFile(const std::string&           searchTarget,
                      const std::filesystem::path& targetFilePath,
                      const bool                   useRegex) {
    std::string output;
    const auto  rgCommand = buildRipgrepSearchFileCommand(searchTarget, targetFilePath, useRegex);
    const auto  errCode   = execCommand(rgCommand, output);

    if (errCode == 0) {
        return std::stoi(output);
    } else if (errCode == 1) {
        return 0;
    } else {
        throw std::runtime_error("rg failed with message: " + output);
        return 0;
    }
}

int ripgrepSearchCmdOutput(const std::string& searchTarget,
                           const std::string& cmd,
                           std::string&       errorOutput,
                           const bool         useRegex) {
    std::string tempOutput;
    const auto  rgCommand = buildRipgrepSearchOutputCommand(searchTarget, cmd, useRegex);
    const auto  errCode   = execCommand(rgCommand, tempOutput);

    if (errCode == 0) {
        return std::stoi(tempOutput);
    } else if (errCode == 1 && tempOutput.empty()) {
        return 0;
    }

    errorOutput = tempOutput;
    return 0;
}

std::string getCurrentTime(const std::string& fmt) {
    std::stringstream ss;
    auto              t  = std::time(nullptr);
    auto              tm = *std::localtime(&t);
    ss << std::put_time(&tm, fmt.c_str());
    return ss.str();
}

std::string buildCommentBlock(const std::vector<std::string>& lines,
                              const std::string&              commentPrefix) {
    if (lines.empty()) { return ""; }
    return strJoin(lines,
                   std::function<std::string(const std::string&)>{
                       [commentPrefix](const std::string& s) { return commentPrefix + " " + s; }},
                   "\n") +
           "\n" + "\n";
}

void writeFile(const std::string& s, const std::filesystem::path& path) {
    if (std::filesystem::exists(path.parent_path())) {
        std::ofstream file(path.string(), std::ofstream::trunc);
        file << s;
    } else {
        throw std::runtime_error("file " + path.string() + " doesn't exist");
    }
}

void writeFile(const std::vector<std::string>& lines, const std::filesystem::path& path) {
    if (std::filesystem::exists(path.parent_path())) {
        std::ofstream file(path.string(), std::ofstream::trunc);
        for (const auto line : lines) { file << line << std::endl; }
    } else {
        throw std::runtime_error("file " + path.string() + " doesn't exist");
    }
}

void writeFileWithHeader(const std::string&           content,
                         const std::filesystem::path& path,
                         const std::string&           commentPrefix,
                         const std::string&           additionalComment) {
    if (content.empty()) { return; }
    std::vector<std::string> comments = {
        "generated by hatter on " + getCurrentTime("%m/%d/%Y %H:%M:%S"),
        "DO NOT EDIT DIRECTLY, ONLY FOR VIEWING/DEBUGGING PURPOSE"};
    if (!additionalComment.empty()) { comments.push_back(additionalComment); }
    writeFile(buildCommentBlock(comments, commentPrefix) + content, path);
}

void appendFile(const std::string& s, const std::filesystem::path& path) {
    if (std::filesystem::exists(path)) {
        std::ofstream file(path.string(), std::ofstream::app);
        file << s;
    } else {
        throw std::runtime_error("file " + path.string() + " doesn't exist");
    }
}

std::string readFile(const std::filesystem::path& path) {
    std::string ret;

    std::ifstream inFile(path.string());
    if (inFile.fail()) { throw std::runtime_error("failed to read file named " + path.string()); }

    std::string line;
    while (std::getline(inFile, line)) { strAddLine(ret, line); }

    if (std::any_of(std::begin(ret), std::end(ret), isalnum)) { return ret; }
    return "";
}

bool strInFile(const std::string& str, const std::filesystem::path& path) {
    return ripgrepSearchFile(str, path);
}

void addOrReplaceLineFile(const std::string&           searchHint,
                          const std::string&           finalLine,
                          const std::filesystem::path& path) {
    if (strInFile(searchHint, path)) {
        execCommand("sed -i 's|.*" + searchHint + ".*|" + finalLine + "|g' " + path.string());
    } else {
        execCommand("printf \"\\n" + finalLine + "\" >> " + path.string());
    }
}

std::string replacePattern(const std::string& str,
                           const std::string& regexPattern,
                           const std::string& replaceStr) {
    return std::regex_replace(str, std::regex(regexPattern), replaceStr);
}

std::string getExeDir(void) {
    char buff[PATH_MAX];
    auto len = readlink("/proc/self/exe", buff, sizeof(buff) - 1);
    if (len != -1) {
        buff[len] = '\0';
        return std::string(dirname(buff));
    }

    return std::string("");
}

std::string toUpper(std::string str) {
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
    return str;
}

std::string strJoin(const std::vector<std::string>& strings, const std::string& delimiter) {
    std::string out;
    size_t      count = 0;

    for (const auto& str : strings) {
        out += str;
        if (count < strings.size() - 1) { out += delimiter; }
        ++count;
    }

    return out;
}

void strAddLine(std::string& dest, const std::string& src) { dest += src + "\n"; }
void strAddLine(std::string& dest, const std::vector<std::string>& src) {
    for (const auto& str : src) { strAddLine(dest, str); }
}
void strAddLine(std::string& dest, const std::initializer_list<std::string>& src) {
    strAddLine(dest, std::vector<std::string>{src});
}
void strAddNonEmptyLine(std::string& dest, const std::string& src) {
    if (!src.empty()) { strAddLine(dest, src); }
}
void strAddNonEmptyLine(std::string& dest, const std::vector<std::string>& src) {
    for (const auto& str : src) { strAddNonEmptyLine(dest, str); }
}
void strAddNonEmptySection(std::string&       dest,
                           const std::string& content,
                           const std::string& sectionName,
                           const std::string& commentPrefix) {
    assert(!sectionName.empty());
    if (content.empty()) { return; }
    strAddLine(dest,
               {
                   commentPrefix + "---START OF " + sectionName + "---",
                   content,
                   commentPrefix + "---END OF " + sectionName + "---",
               });
}

bool inStr(const std::string& strToLookFor, const std::string& strToSearchIn) {
    if (strToSearchIn.find(strToLookFor) != std::string::npos) { return true; }
    return false;
}

std::vector<std::string> strSplit(std::string str, const std::string& delimiter, int limit) {
    std::vector<std::string> ret;
    size_t                   pos = 0;

    if (limit == 0) { limit = static_cast<int>(str.length()) + 2; }

    while (((pos = str.find(delimiter)) != std::string::npos) && (limit > 0)) {
        ret.push_back(str.substr(0, pos));
        str.erase(0, pos + delimiter.length());
        --limit;
    }
    ret.push_back(str);

    return ret;
}

template <>
void appendUniqueVector(std::vector<std::filesystem::path>&       dest,
                        const std::vector<std::filesystem::path>& src) {
    for (const auto& target : dest) {
        if (std::any_of(std::begin(src), std::end(src), [target](const auto& s) {
                return s.string() == target.string();
            })) {
            break;
        }
        dest.push_back(target);
    }
    auto newEnd = std::remove_if(
        std::begin(dest), std::end(dest), [](const auto& path) { return path.string().empty(); });
    dest.erase(newEnd, std::end(dest));
}

int execCommand(const std::string& cmd) {
    std::string temp;
    (void)temp;
    return execCommand(cmd, temp);
}
int execCommand(const std::string& cmd, std::string& output, const size_t outputBufferSize) {
    std::vector<char> buffer(outputBufferSize);
    auto              pipe = popen(cmd.c_str(), "r");

    if (!pipe) { throw std::runtime_error("popen() failed on command: " + cmd); }

    while (!feof(pipe)) {
        if (fgets(buffer.data(), static_cast<int>(buffer.size()), pipe) != nullptr) {
            output += buffer.data();
        }
    }

    return WEXITSTATUS(pclose(pipe));
}
}  // namespace hatter